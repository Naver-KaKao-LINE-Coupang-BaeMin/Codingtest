import sys
input = sys.stdin.readline

n = int(input())
mod = 10007

'''
    가로, 세로, 대각선 방향 한 타일씩 불이 퍼져 나간다
    민수, 기웅이도 아래, 대각 오른 아래한칸씩 움직일 수 있다.
    같은 칸에 간다면 끝
    문은 마지막 맨 밑
    이 경우의 수는?
    n=1이라 가정해보자
    이건 방법이 없다
    dp로 중복되는 경우를 줄이는 것이 옳아 보인다.
    최종 목적지는 문이고, 그 문까지 가기 위해 그 전단계에서 움직임의 가능성은 제한되어 있다.
    그림에서 N=5인 경우에 문 바로 직전 상황을 보자
    만약 A가 맨 왼쪽에 있다 그럼 일반적으로 아래, 대각 아래 두가지 케이스이네
    B가 바로 옆에 있으면 선택지가 제한이 된다.(대각 아래의 경우 그냥 B가 아래가면 서로 부딪친다)
    반대로 두칸 이상 떨어져있다면 둘다 어떤 방향으로가도 ok
    
'''
dp = [[0 for _ in range(100 + 1)] for _ in range(100 + 1)] # 현재 높이, 그리고 둘 사이 간격을 보자
# 일단 dp가 높이가 1이면 그냥 0이다
# 2일때에는 서로의 거리의 차는 무조건 1이다.
dp[2][1] = 2
# 3일때에는
dp[3][1] = 4 
dp[3][2] = 2
# 4일때에는
dp[4][1] = 10
dp[4][2] = 8
dp[4][3] = 2
# 5일떄에는
dp[5][1] = 28
dp[5][2] = 28
dp[5][3] = 12
dp[5][4] = 2
# 사실상 끝은 2가 고정이고
'''
    4,2을 만들려면
    위에 n-1에서 봐야한다. 위에 n-1기준 똑같이 거리가 같은 애들 기준이라고 쳐보자
    그냥 그 위 기준에선 바로 아래로 내려올 수도 있고, 대각선으로 와도 거리는 2이 맞춰진다.
    반대로 거리가 3이었다가 준 애도 있을 것이다. 예를 들어 하나는 대각선 아래 내려오면 거리가 줄어든다
    이 경우는 경우의 수가 그 횟수밖에 없다.
    마찬가지로 늘리면서 올 수도 있을 것이다. 아래 대각선으로 내려오면
'''
for i in range(6,n+1):
    for j in range(1,i):
        dp[i][j] = (dp[i-1][j] + dp[i-1][j] + dp[i-1][j-1] + dp[i-1][j+1]) % mod
print(sum(dp[n]) % mod)